{"body":"\r\n# VoodOrm\r\n\r\n---\r\n\r\nName: VoodOrm\r\n\r\nversion: 0.3.x\r\n\r\nLicense: MIT\r\n\r\nAuthor: [Mardix](http://github.com/mardix)\r\n\r\n---\r\n\r\n## About Voodoo!\r\n\r\nVoodOrm is a micro-ORM which functions as both a fluent select query API and a CRUD model class.\r\n\r\nVoodOrm is built on top of PDO and is well fit for small to mid-sized projects, where the emphasis \r\nis on simplicity and rapid development rather than infinite flexibility and features.\r\nVoodOrm works easily with table relationship. And offers api that gets SQL out of your way\r\n\r\n--- \r\n\r\n## Features\r\n\r\n- PDO and prepared statements\r\n- Fluent Query\r\n- Relationship\r\n- Joins\r\n- Aggregation\r\n- Query debugger and query profiler\r\n- Active Record pattern\r\n\r\n## Requirements\r\n\r\n- PHP >= 5.3\r\n- PDO\r\n\r\n## Error Reporting\r\nVoodOrm does not escalate errors. Non-existing table produces SQL error that is reported by PDO conforming to PDO::ATTR\\_ERRMODE. Non-existing columns produces the same E_NOTICE as an attempt to access non-existing key in array.\r\n\r\n## What it doesn't do. \r\n\r\nWe believe it's best if certain stuff is kept to the developer to do, like caching or data validation. Also data validation can be done at the database level, like \r\n\r\n- No models or entities generation\r\n- No data validation\r\n- No caching\r\n- No database migration\r\n\r\n\r\n---\r\n## Working with VoodOrm\r\n\r\n---\r\n### ***new VoodOrm(*** *PDO $pdo* ***)***\r\n\r\nTo get started with VoodOrm, you have to setup the PDO connection. We'll be using the variable $DB as the database connection, `$users` as the table, `$friends` as another table throughout this whole tutorial\r\n\r\n\t$pdo = new PDO(\"mysql:host=localhost;dbname=$dbname\", $username, $password);\r\n\t$DB = new VoodOrm($pdo);\r\n\r\n---\r\n\r\n### *VoodOrm* ***VoodOrm::table(*** *string $tablename* ***)*** \r\nTo connect to a table is straight forward by calling the method `VoodOrm::table()` \r\n\r\n\t$users = $DB->table('users');\r\n\r\nYou can also set the table by calling the table as a method. The above can be also written like this\r\n\t\r\n\t$users = $DB->users();\r\n\t$friends = $DB->friends();\r\n\r\n\r\nFrom there you will be able able to do any CRUD on the table with VoodOrm fluent query interface\r\n\r\n---\r\n##Data Modification\r\n\r\nVoodOrm supports data modification (insert, update and delete). No data validation is performed by VoodOrm but all database errors are reported by the standard PDO error reporting. For data validation, we believe it's best to validate your data at the database level or application level\r\n\r\n---\r\n\r\n### *mixed* ***VoodOrm::insert(*** *Array $data* ***)***\r\nTo insert data in the table, use the `insert(Array $data)` where `$data` can be a one dimentional array to insert  just one entry, or a muliple arrays to do mass insert. \r\n\r\nIf a single row was inserted, it will return the active record of the created object. Otherwise it will return the total entries inserted\r\n\r\nFor a single entry:\r\n\r\n\t$user = $users->insert(array(\r\n\t\t \t\t\t\"name\" => \"Mardix\",\r\n\t\t\t\t\t\"age\" => 30, \r\n\t\t \t\t\t\"city\" => \"Charlotte\",\r\n\t     \t\t\t\"state\" => \"NC\",\r\n\t\t\t\t\t\"device\" => \"mobile\",\r\n\t\t \t\t\t\"timestamp\" => $voodorm->Datetime()\r\n\t\t\t\t));\r\n\r\nReturns the VoodOrm active record instance of this entry where you can use\r\n`$user->name` or `$user->city`. We'll be able to do more later.\r\n\r\nFor a mass insert:\r\n\r\n\t$massInserts = $users->insert(array(\r\n\t\t\t\t\t\tarray(\r\n\t\t\t\t\t\t\t \"name\" => \"Mardix\",\r\n\t\t\t\t\t\t\t \"city\" => \"Charlotte\",\r\n\t\t\t\t\t\t     \"state\" => \"NC\",\r\n\t\t\t\t\t\t     \"device\" => \"mobile\",\r\n\t\t\t\t\t\t\t \"timestamp\" => $voodorm->Datetime()\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t\tarray(\r\n\t\t\t\t\t\t\t \"name\" => \"Cesar\",\r\n\t\t\t\t\t\t\t \"city\" => \"Atlanta\",\r\n\t\t\t\t\t\t     \"state\" => \"GA\",\r\n\t\t\t\t\t\t\t \"device\" => \"mobile\",\r\n\t\t\t\t\t\t\t \"timestamp\" => $voodorm->Datetime()\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t\tarray(\r\n\t\t\t\t\t\t\t \"name\" => \"Gaga\",\r\n\t\t\t\t\t\t\t \"city\" => \"Port-au-Prince\",\r\n\t\t\t\t\t\t     \"state\" => \"HT\",\r\n\t\t\t\t\t\t\t \"device\" => \"computer\",\r\n\t\t\t\t\t\t\t \"timestamp\" => $voodorm->Datetime()\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t));\r\n\r\nreturns the total entries that were inserted\r\n\r\n---\r\n\r\n### *mixed* ***VoodOrm::update(Array $data)***\r\n \r\nThere are two ways to update entries in VoodOrm, 1) by using the active record pattern for a fetched row, or 2) by using a where query to specify where to update. Also the method `VoodOrm::set($key, $value)` can be use to set the data before updating.\r\n\r\n***For single entry***\r\n\r\n\t$user->update(array(\r\n\t\t\t\t\t\t\"city\" => \"Raleigh\"\r\n\t\t\t\t\t));\r\n\r\nit's the same as\r\n\r\n\t$user->city = \"Raleigh\";\r\n\t$user->update();\r\n\r\nYou can use `save()` instead of `update()`\r\n\r\n\t$user->save();\r\n\r\n\r\nor with *Voodoo::set(Array $data) or Voodoo::set($key, $value)*\r\n\r\n\t$user->set('city','Raleigh')->update();\r\n\r\n***For multiple entries:***\r\n\r\nFor multiple entries we'll use `VoodOrm::set()` and `VoodOrm::where()` to specify where to update.\r\n\r\n*Voodoo::set(Array $data) or Voodoo::set($key, $value)*\r\n\r\nFor mass update, we'll set the data to update using `set(Array $data)` and `where($k, $v)`\r\n\r\n\t$user->set(array(\r\n\t\t\t\t\t\"country_code\" => \"US\"\r\n\t\t\t))\r\n\t\t\t->where(\"device\", \"mobile\")\r\n\t\t\t->update();\r\n\r\n**There are more fluent `where` aliases under Fluent Query Interface*\r\n\r\n---\r\n\r\n### *mixed* ***VoodOrm::save()***\r\n`Save()` is a shortcut to `VoodOrm::insert()` or `VoodOrm::update()`\r\n\r\nTo insert new data:\r\n\r\n\t$user = $DB->users();\r\n\t$user->name = \"Mardix\";\r\n\t$user->city = \"Charlotte\";\r\n\t$user->save(); \r\n\r\nTo update:\r\n\r\n\t$user = $users->findOne(123456);\r\n\t$user->city = \"Atlanta\";\r\n\t$user->save();\r\n\r\n---\r\n\r\n### *int* ***VoodOrm::delete()***\r\nTo delete entries we'll use the `VoodOrm::delete()` method\r\n\r\nFor single entries, by invoking the `delete()` method it will delete the current entry\r\n\r\n\t$singleEntry->delete();\r\n\r\nFor multiple entries, we will use the `VoodOrm::where()` method to specify where to delete\r\n\r\n\t$voodorm->where($x, $y)->delete();\r\n\r\n---\r\n\r\n## Aggregation\r\n\r\nVoodOrm gives you access to aggregation methods on your table\r\n\r\n---\r\n\r\n#### *int* ***VoodOrm::count()***\r\nTo count all the entries based on where clause\r\n\r\n\t$count = $voodorm->where($x, $y)->count();\r\n\r\nor for a specific column name\r\n\r\n\t$count = $voodorm->where($x, $y)->count($columnName);\r\n\r\n\r\n#### *float* ***VoodOrm::max(*** *string $columnName* ***)***\r\nTo get the max of a $columnName based on where() clause\r\n\r\n\t$max = $voodorm->where($x, $y)->max($columnName);\r\n\r\n\r\n#### *float* ***VoodOrm::min(*** *string $columnName* ***)***\r\nTo get the min of a $columnName based on where() clause\r\n\r\n\t$min = $voodorm->where($x, $y)->min($columnName);\r\n\r\n\r\n#### *float* ***VoodOrm::sum(*** *string $columnName* ***)***\r\nTo get the sum of a $columnName based on where() clause\r\n\r\n\t$sum = $voodorm->where($x, $y)->sum($columnName);\r\n\r\n\r\n#### *float* ***VoodOrm::avg(*** *string $columnName* ***)***\r\nTo get the average of a $columnName based on where() clause\r\n\r\n\t$avg = $voodorm->where($x, $y)->avg($columnName);\r\n\r\n#### *mixed* ***VoodOrm::aggregate(*** *string $function* ***)***\r\nTo run any aggregation function\r\n\r\n\t$agg = $voodorm->where($x, $y)->aggregate('GROUP_CONCAT $columnName');\r\n\r\n---\r\n\r\n## Querying\r\nVoodOrm provides a fluent interface to enable simple queries to be built without writing a single character of SQL. \r\n\r\nTwo main methods allow you to get a single entry or multiple entries. \r\n\r\n---\r\n## FindOne\r\n\r\n### *VoodOrm* ***VoodOrm::findOne()***\r\n\r\n`findOne()` returns `VoodOrm` instance of a single entry if found, otherwise it will return `FALSE`.\r\n\r\n\r\n\t$user = $users->where('id', 1234)\r\n\t\t\t\t  ->findOne();\r\n\r\nThe primary key can be set in the `findOne(int $primaryKey)` to get the same result as the above query. Meaning no need to have a `where()` clause.\r\n\r\n \t$user = $users->findOne(1234);\r\n\r\nLet's get the entry found:\r\n\r\n\tif ($user) {\r\n\t\techo \" Hello $user->name!\";\r\n\r\n\t// On a retrieved entry you can perform update and delete\r\n\t\t$user->last_viewed = $users->DateTime();\r\n\t\t$suer->save();\r\n\t}\r\n\r\n---\r\n\r\n## Find\r\n\r\n### *ArrayIterator* ***VoodOrm::find()***\r\n`find()` returns an `ArrayIterator` of the rows found which are instances of `VoodOrm`, otherwise it will return `False`. \r\n\r\n\t$allUsers = $users->where('gender', 'male')\r\n\t\t\t\t\t  ->find();\r\n\r\n\tforeach ($allUsers as $user) {\r\n\t\techo \"{$user->name}\";\r\n\r\n\t// On a retrieved entry you can perform update and delete\r\n\t\t$user->last_viewed = $users->DateTime();\r\n\t\t$user->save();\r\n\t}\r\n\r\n`find()` also contains a shortcut when it's called in an iteration such as foreach:\r\n\r\n\t$allUsers = $users->where('gender', 'male');\r\n\r\n\tforeach ($allUsers as $user) {\r\n\t\techo \"{$user->name}\";\r\n\r\n\t// On a retrieved entry you can perform update and delete\r\n\t\t$user->last_viewed = $users->DateTime();\r\n\t\t$suer->save();\r\n\t}\r\n\t\t\t\t\t  \r\n\r\n### *mixed* ***VoodOrm::find(*** *Closure $callback* ***)***\r\n\r\n`VoodOrm::find()` also accept a Closure as a callback to do your own data manipulation. Upon execution, VoodOrm will pass the data found from the query to the closure function.\r\n\r\n\t\t$users->where('gender', 'male');\r\n\r\n\t\t$results = $users->find(function($data){\r\n\t\t\t$newResults = array();\r\n\r\n\t\t\tforeach ($data as $d) {\r\n\t\t\t\t$d[\"full_name\"] = ucwords(\"{$data[\"first_name\"]} {$data[\"last_name\"]}\");\r\n \t\t\t\t$newResults[] = $d;\r\n\t\t\t}\r\n\r\n\t\t\treturn $newResults;\r\n\t\t});\t\r\n\r\n---\t\r\n\r\n## Fluent Query Builder\r\n\r\n---\r\n\r\n\r\n\r\n## Select\r\n\r\n### *VoodOrm* ***VoodOrm::select(*** *$columns = '\\*'*  ***)***\r\nTo select the fields in the table. If ommitted, VooOrm will fetch all the columns.\r\n\r\n\t$users->select()\r\n\r\nor with selected columns\r\n\r\n\t$users->select(\"name, age, last_viewed\");\r\n\r\n\tSELECT name, age, last_viewed\r\n\r\n---\r\n\r\n## Where\r\n\r\n`Where` allow you to set where clauses for the query. Below you will find many aliases for `where`\r\n\r\n`Where` clauses work with VoodOrm::find()` , `VoodOrm::findOne()`, `VoodOrm::update()` and `VoodOrm::delete()`\r\n\r\nRepetitive call of `where` or any `where` aliases will append the where clause to the previous where by using the AND operator. To use the OR operator instead you must call to `VoodOrm::_or()`. More below.\r\n\r\n\r\n### *VoodOrm* ***VoodOrm::where(*** *$condition $parameters = array()*  ***)***\r\n\r\nThis is the main `where`. It is responsible for all the wheres.\r\n\r\n`$condition` is the condition to use. It can contain ? or :name which is bound by PDO to `$parameters` (so no manual escaping is required).\r\n\r\n\r\n`$parameters` is the value(s) to bind to the condition. It can be one array, one associative array or zero or more scalars. \r\n\r\nSom examples\r\n\r\n\t$users->where(\"name\", \"Mardix\");\r\n\tWHERE name = ?\r\n\r\n\t$users->where(\"age > ?\", 25);\r\n\tWHERE age > ?\r\n\r\n\t$users->where(\"name in (?, ?, ?)\", \"Mike\", \"Jones\", \"Rich\");\r\n\tWHERE name IN (?, ?, ?)\r\n\r\n\t$users->where(\"(field1, field2)\", array(array(1, 2), array(3, 4)))\r\n\tWHERE (field1, field2) IN ((?, ?), (?, ?))\r\n\r\nBut to facilitate the task, VoodOrm comes with some aliases for common operation:\r\n### *VoodOrm* ***VoodOrm::wherePK(*** *int $primaryKey*  ***)***\r\nWhere the primary key is set\r\n\t$users->wherePK(1234);\r\n\r\n### *VoodOrm* ***VoodOrm::whereNot(*** *$columnName, $value*  ***)***\r\n\r\n\t$users->whereNot('age', 24);\r\n\r\n\tWHERE age != ?\r\n\r\n\t\r\n### *VoodOrm* ***VoodOrm::whereLike(*** *$columnName, $value*  ***)***\r\n\r\n\t$users->whereLike('name', 'w%');\r\n\r\n\tWHERE name LIKE ?\r\n\r\n### *VoodOrm* ***VoodOrm::whereNotLike(*** *$columnName, $value*  ***)***\r\n\t$users->whereNotLike('name', 'r%');\r\n\r\n\tWHERE name NOT LIKE ?\r\n\r\n### *VoodOrm* ***VoodOrm::whereGt(*** *$columnName, $value*  ***)***\r\n\t$users->whereGt('age', 21);\r\n\r\n\tWHERE age > ?\r\n\r\n### *VoodOrm* ***VoodOrm::whereGte(*** *$columnName, $value*  ***)***\r\n\t$users->whereGte('age', 21);\r\n\r\n\tWHERE age >= ?\r\n\r\n### *VoodOrm* ***VoodOrm::whereLt(*** *$columnName, $value*  ***)***\r\n\t$users->whereLt('age', 21);\r\n\r\n\tWHERE age < ?\r\n\r\n### *VoodOrm* ***VoodOrm::whereLte(*** *$columnName, $value*  ***)***\r\n\t$users->whereLte('age', 21);\r\n\r\n\tWHERE age <= ?\r\n\r\n### *VoodOrm* ***VoodOrm::whereIn(*** *$columnName, Array $value*  ***)***\r\n\t$users->whereIn('city', array('Charlotte', 'Atlanta'));\r\n\r\n\tWHERE city IN (?,?)\r\n\r\n### *VoodOrm* ***VoodOrm::whereNotIn(*** *$columnName, Array $value*  ***)***\r\n\t$users->whereNotIn('city', array('Chicago', 'Miami'));\r\n\r\n\tWHERE city NOT IN (?,?)\r\n\r\n### *VoodOrm* ***VoodOrm::whereNull(*** *$columnName*  ***)***\r\n\t$users->whereNull('city');\r\n\r\n\tWHERE city IS NULL\r\n\r\n### *VoodOrm* ***VoodOrm::whereNotNull(*** *$columnName*  ***)***\r\n\t$users->whereNotNull('name');\r\n\r\n\tWHERE city NOT NULL\r\n\r\n---\r\n\r\n## Where with OR and AND\r\nBuilding your query, you will want to add AND and OR operator in your where clause. To do so, use `VoodOrm::_and()` and `VoodOrm::_or()` chained to any `where` aliases\r\n \r\n### *VoodOrm* ***VoodOrm::_and()***\r\nTo add the `AND` operator in a where query. `AND` is set by default, if not `_and()` is not called, VoodOrm will add it by default. \r\n\r\n\t$users->where(\"city\", \"Charlotte\")->_and()->whereGte(\"age\", 21);\r\n\r\n\tWHERE city = ? AND age >= ?\r\n\r\n\r\n### *VoodOrm* ***VoodOrm::_or()***\r\nTo add the `OR` operator in a where query.\r\n\r\n\t$users->where(\"city\", \"Charlotte\")->_or()->whereGte(\"age\", 21)->_or()->where(\"gender\", \"female\");\r\n\r\n\tWHERE city = ? OR age >= ? OR gender = ?\r\n\t\r\n---\r\n\r\n## Where with Wrap()\r\nWhen building quasi complicated query with multiple set of where, `VoodOrm::wrap()` group the where together in parenthesis. \r\n\r\n### *VoodOrm* ***VoodOrm::wrap()***\r\n\r\n\t$users->where(\"city\", \"Charlotte\")->whereGte(\"age\", 21)->wrap()\r\n\t\t  ->where(\"gender\", \"female\")->where(\"city\", \"Atlanta\");\r\n\r\n\tWHERE (city = ? AND age >= ?) AND (gender = ? AND city = ?)\r\n\r\n### *VoodOrm* ***VoodOrm::wrap()->_and()***\r\n\r\n`wrap()->_and()` does a union with another grouped where with the `AND` operator.\r\n\r\n\t$users->where(\"city\", \"Charlotte\")->whereGte(\"age\", 21)->wrap()->_and()\r\n\t\t  ->where(\"gender\", \"female\")->where(\"city\", \"Atlanta\");\r\n\r\n\tWHERE (city = ? AND age >= ?) AND (gender = ? AND city = ?)\r\n\r\n### *VoodOrm* ***VoodOrm::wrap()->_or()***\r\n\r\n`wrap()->_or()` does a union with another grouped where with the `OR` operator.\r\n\r\n\t$users->where(\"city\", \"Charlotte\")->whereGte(\"age\", 21)->wrap()->_or()\r\n\t\t  ->where(\"gender\", \"female\")->where(\"city\", \"Atlanta\");\r\n\r\n\tWHERE (city = ? AND age >= ?) OR (gender = ? AND city = ?)\r\n\r\n#### wrap()->\\_and() and wrap()->\\_or() in the same query\r\n\r\n\t$users->where(\"id\",1)->where(\"city\",\"charlotte\")->wrap()\r\n\t      ->where(\"gender\",\"female\")->where(\"country\",\"US\")->wrap()\r\n\t      ->_or()->where(\"city\",array(\"Charlotte\",\"Atlanta\"))->wrap()\r\n\t      ->_or()->whereLt('age',21)->whereGte(\"name\",\"Mardix\")->wrap();\r\n\t\r\n\tWHERE (id = ? AND city = ?) \r\n\t\t  AND (gender = ? AND country = ?) \r\n          OR ((city IN (?, ?))) \r\n\t      OR (age < ? AND name >= ?) \r\n\r\n---\r\n\r\n## Order, Group, Limit, Offset\r\n\r\n### *VoodOrm* ***VoodOrm::orderBy(*** *$columnName, $ordering*  ***)***\r\n\t$users->orderBy('name', 'DESC');\r\n\r\n\tORDER BY name DESC\r\n\r\n### *VoodOrm* ***VoodOrm::groupBy(*** *$columnName*  ***)***\r\n\t$users->groupBy('city');\r\n\r\n\tGROUP BY city\r\n\r\n### *VoodOrm* ***VoodOrm::limit(*** *int $limit*  ***)***\r\n\t$users->limit(10);\r\n\r\n\tLIMIT 10\r\n\r\n### *VoodOrm* ***VoodOrm::offset(*** *int $offset*  ***)***\r\n\t$users->offset(10);\r\n\r\n\tOFFSET 10\r\n\r\n---\r\n## Joins\r\n### *VoodOrm* ***VoodOrm::join(*** *$tablename, $constraint, $table_alias , $join_operator* ***)***\r\n\t$users->join('friends', 'f.user_id = u.id', 'f')\r\n\r\n\tJOIN friends AS f ON f.user_id = u.id\r\n\r\n### *VoodOrm* ***VoodOrm::leftJoin(*** *$tablename, $constraint, $table_alias* ***)***\r\n\t$users->leftJoin('friends', 'f.user_id = u.id', 'f')\r\n\r\n\tLEFT JOIN friends AS f ON f.user_id = u.id\r\n\r\n---\r\n\r\n## Relationship\r\nThat's the killer!\r\n\r\nOne of VoodOrm killer feature is Relationship. By calling q table as a method on an object automatically creates a One To Many relationship on that reference table by default.\r\n\r\nFor this example we'll have two tables: `user` (id, name, dob) and `friend` (id, user\\_id, friend\\_id)\r\n\r\nThe `friend.user_id` is the foreign key to the `user` table. And `friend.friend_id` is the foreign key of the friend's `user.id`.\r\n\r\nLet's get all the users and their friends\r\n\r\n    $allUsers = $users->find();\r\n\t\r\n    foreach ($allUsers as $user) {\r\n        /**\r\n        * Connect to the 'friend' table = $user->friend();\r\n        * In the back, it does a ONE To MANY relationship \r\n        * SELECT * FROM friend WHERE friend.user_id = user.id \r\n        */\r\n        $allFriends = $user->friend();\r\n        foreach ($allFriends as $friend) {\r\n            echo \"{$friend->friend_id} : \";\r\n\r\n            /**\r\n            * We got the friend's entry, we want to go back in the user table\r\n            * So we link back the friend table to the user table\r\n            * SELECT * FROM user WHERE user.id = friend.friend_id LIMIT 1 \r\n            * It will do a ONE to One relationship\r\n            */\r\n            echo $friend->user(Voodoo\\Core\\VoodOrm::REL_HASONE, \"friend_id\")->name;\r\n\r\n            echo \"\\n\";\r\n        }\r\n    }\r\n    \r\n    // Same as above but with just one user\r\n    $user = $users->findOne($userId);\r\n    if($user) {\r\n\r\n        foreach ($user->friend() as $friend) {\r\n\r\n            echo \"{$friend->friend_id} : \";\r\n\r\n            echo $friend->user(Voodoo\\Core\\VoodOrm::REL_HASONE, \"friend_id\")->name;\r\n\r\n            echo \"\\n\";\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\nThat's the big picture. Calling a reference table as a method on a object will do a relationship. \r\n\r\n## Relationship: *One to Many*\r\n\r\nOne to many relationship, in our user and friend case, it's where a user can have one or more friends. But each `friend.friend_id` is associated to one `user.id`. This type of relationship will return one or more entries. \r\n\r\nThe relationship between `user` (single-valued) and `friend` (multi-valued) is a one-to-many relationship. \r\n\r\nIn our above example, we did a One to Many relationship in the friend's table\r\n\r\n\t$allFriends = $user->friend();\r\n\r\nRelationship Constants\r\n\r\nVoodOrm has pre-defined constant that let you select execute a type of relationship\r\n\r\n*CONST::REL\\_HASMANY (2)*\r\n\r\n\t$allFriends = $user->friend(Voodoo\\Core\\VoodOrm::REL_HASMANY);\r\n\r\nThis is faster. It does an eager loading by fetching all the data and hold the data in memory. It executes only one query. It is used by default.\r\n\r\n\r\n*CONST::REL\\_LAZYMANY (-2)*\r\n\r\n\t$allFriends = $user->friend(Voodoo\\Core\\VoodOrm::REL_LAZYMANY);\r\n\r\nThis is slower. It does a lazy loading by fetching the data as it's being requested. It will execute 1+N queries.\r\n\r\n\r\n\r\n## Relationship: *One to One*\r\nOne-to-one relationships are single-valued in both directions. In the friend's table, `friend.friend_id` is linked to `user.id`  \r\n\r\n\t$allFriends = $user->friend();\r\n\r\nRelationship Constants\r\n\r\n*CONST::REL\\_HASONE (1)*\r\n\r\n\t$friendUser = $friend->user(Voodoo\\Core\\VoodOrm::REL_HASONE, \"friend_id\");\r\n\techo $friendUser->name;\r\n\r\nIt does an eager loading by fetching all the data and hold the data in memory. It executes only one query. It is used by default.\r\n\r\n*CONST::REL\\_LAZYONE (-1)*\r\n\r\n\t$friendUser = $friend->user(Voodoo\\Core\\VoodOrm::REL_LAZYONE, \"friend_id\");\r\n\techo $friendUser->name;\r\n\r\nThis is slower. It does a lazy loading by fetching the data as it's being requested. It will execute 1+N queries.\r\n\r\n\r\n\r\n#### Relationship: *Many to Many*\r\nNot implemented. That shit is complicated.... can't find a one case fit all... \r\n\r\n## Relationship Parameters\r\n\r\nVoodOrm relationship accept 4 types of parameters that can be placed anywhere:\r\n\r\n\t$user->friend(NUMBER, STRING, ARRAY, CALLBACK);\r\n\r\n**NUMBER** : Usually that's the relationship constants `REL_HASONE = 1`, `REL_LAZYONE = -1`, `RE_HASMANY = 2`, `REL_LAZYMANY = -2`;\r\n\r\n\t$user->friend(Voodoo\\Core\\VoodOrm::REL_HASMANY);\r\n\r\n**STRING**: Having a tring as an argument will be used as a foreign key name\r\n\r\n\t$user->friend(\"friend_id\");\r\n\t\r\n\r\n**ARRAY** : Array will be used as a WHERE condition. Array must be a key/value matching the fields in the table\r\n\r\n\t$user->friend(array(\r\n\t\t\"friendship_start_time >= \" => date(\"Y-m-d\")\r\n\t));\r\n\r\n**CALLBACK**: Callback is a function to run on the results\r\n\r\n\t$user->friend(function($data){\r\n\r\n\t\t$tableData = array();\r\n\r\n\t\tforeach($data as $d) {\r\n\t\t\t$tableData[] = array_merge(\r\n\t\t\t\t\t\t\t\t$data,\r\n\t\t\t\t\t\t\t\tarray(\"visits_count\"=>$d[visits_count] + 1)\r\n\t\t\t\t\t\t\t); \r\n\t\t}\r\n\t\treturn $tableData;\r\n\t}); \r\n\r\nNow do the Pot Pourri!\r\n\r\n\t$user->friend(Voodoo\\Core\\VoodOrm::REL_HASONE, \r\n\r\n\t\t\t\t\t\"friend_id\", \r\n\r\n\t\t\t\t\tarray(\"friendship_start_time >= \" => date(\"Y-m-d\"),\r\n\r\n\t\t\t\t\tfunction($data){\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t\t$tableData = array();\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t\tforeach($data as $d) {\r\n\t\t\t\t\t\t\t\t$tableData[] = array_merge(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t$data,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tarray(\"visits_count\"=>$d[visits_count] + 1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn $tableData;\r\n\t\t\t\t\t\t}\t\t\t\r\n\t));\r\n\r\n\r\n\r\n\t$user->friend(NUMBER, STRING, ARRAY, CALLBACK);\r\n\r\n---\r\n\r\n## Table Structure\r\n\r\nTable structure allows to define the table structure in the database. It is set on the constructor\r\n\r\n\tnew VoodOrm(PDO, $primaryKey = 'id', $foreignKey = '%s_id', $tablePrefix = '')\r\n\r\nPRIMARYKEY : by default is set to `id` but can be anything\r\n\r\nFOREIGNKEY : Is the foreign key. By default it is set %s_id where %s is the table name. So a table user, in a friend table the foreign key will be `user_id`\r\n\r\nTABLEPREFIX : The table prefix\r\n\r\nYou can pass an array in the second param to set the table structure\r\n\r\n\tnew VoodOrm(PDO, array(\r\n        \"primaryKeyName\"    => \"id\",\r\n        \"foreignKeyName\"    => \"%s_id\",\r\n        \"tablePrefix\"       => \"\"\r\n      ));\r\n\r\n---\r\n## Advanced\r\n\r\nto be added...\r\n\r\n\r\n---\t\r\nCredits\r\n\r\nThanx to NotORM and Idiorm. They inspired me to make VoodOrm. \r\n\r\n---\r\n\r\nContributers \r\n\r\nIf you would like to contribute, thank you for your interest. Please do a pull request.\r\n\r\n---\r\n\r\nCoding style\r\n\r\nVoodOrm follows closely PSR-2\r\n\r\n","tagline":"VoodOrm: a fluent SQL query builder on top of PDO. It makes writing queries and CRUD painless. Works well with table relationships","name":"Voodorm","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}